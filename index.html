<!DOCTYPE html>
<html lang="en">
<head>
    <link rel="shortcut icon" href="#">
    <meta charset="UTF-8">
    <title>TEI Entities Browser</title>
    <link href="https://unpkg.com/tabulator-tables/dist/css/tabulator.min.css" rel="stylesheet">
    <script type="text/javascript" src="https://unpkg.com/tabulator-tables/dist/js/tabulator.min.js"></script>
    <script type="text/javascript" src="https://oss.sheetjs.com/sheetjs/xlsx.full.min.js"></script>
    <script type="text/javascript">
        Tabulator.extendModule("format", "formatters", {
            bold:function(cell, formatterParams){
                return "<strong>" + cell.getValue() + "</strong>"; //make the contents of the cell bold
            },
            uppercase:function(cell, formatterParams){
                return cell.getValue().toUpperCase(); //make the contents of the cell uppercase
            }
        });
    </script>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            max-width: 1200px;
            margin: 0 auto;
        }
        #loading {
            text-align: center;
            margin-top: 50px;
            font-size: 1.2em;
            color: #666;
        }
        #errorContainer {
            color: red;
            text-align: center;
            margin: 20px;
        }
        #jsonContainer {
            white-space: pre-wrap;
            background-color: #f5f5f5;
            border: 1px solid #ddd;
            padding: 10px;
            margin: 20px;
            max-height: 200px;
            overflow: auto;
        }
        #filters {
            margin-bottom: 10px;
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }
        #searchBar {
            width: 200px;
            padding: 10px;
            font-size: 16px;
            border: 1px solid #ddd;
        }
        #entityTable {
            margin-top: 10px;
            width: 100%;
            display: none;
        }
        label {
            font-weight: bold;
        }
        select {
            padding: 5px;
            font-size: 16px;
        }

        .tabulator .tabulator-header .tabulator-col {
            background: #b3e1d9
        }
        
        .clickable-name {
            text-decoration: underline;
            cursor: pointer;
            color: #0066cc;
        }
        
       /* Entity popup styles */
.entity-popup {
    position: absolute;
    z-index: 1000;
    background-color: #fff;
    border: 1px solid #ddd;
    border-radius: 4px;
    padding: 0;
    max-width: 400px;
    box-shadow: 0px 0px 10px rgba(0,0,0,0.3);
    font-family: Arial, sans-serif;
}

.entity-popup-header {
    padding: 15px;
    border-bottom: 1px solid #eee;
    position: relative;
    display: flex;
    align-items: center;
}

.entity-popup-icon {
    margin-right: 15px;
}

.entity-popup-name {
    margin: 0;
    font-size: 1.3em;
    font-weight: bold;
}

.entity-popup-close {
    position: absolute;
    right: 10px;
    top: 10px;
    cursor: pointer;
    color: #b35900;
}

.entity-popup-content {
    padding: 15px;
}

.entity-popup-section {
    margin-bottom: 15px;
}

.entity-popup-section-title {
    font-weight: bold;
    margin-top: 0;
    margin-bottom: 5px;
}

.entity-popup-list {
    margin: 0;
    padding-left: 20px;
}

.entity-popup-lang {
    color: #666;
}

.entity-popup-project {
    color: #b35900;
    font-style: italic;
}

.entity-popup-gnd {
    margin-top: 15px;
}

.entity-popup-link {
    color: #b35900;
    text-decoration: underline;
}


    </style>
</head>
<body>
    <div id="loading">Loading entities, please wait...</div>
    <div id="errorContainer"></div>
    <div id="jsonContainer"></div>

    <!-- Filter section -->
    <div id="filters">
        <div>
            <label for="languageFilter">Language:</label>
            <select id="languageFilter">
                <option value="">All</option>
                <!-- Dynamic language options will be populated here -->
            </select>
        </div>

        <div>
            <label for="projectFilter">Project:</label>
            <select id="projectFilter">
                <option value="">All</option>
                <!-- Dynamic project options will be populated here -->
            </select>
        </div>

        <div>
            <label for="linkFilter">Link:</label>
            <select id="linkFilter">
                <option value="">All</option>
                <!-- Dynamic link options will be populated here -->
            </select>
        </div>

        <div>
            <label for="typeFilter">Type:</label>
            <select id="typeFilter">
                <option value="">All</option>
                <!-- Dynamic link options will be populated here -->
            </select>
        </div>

        <!-- Search bar next to link filter -->
        <div>
            <label for="searchBar">Search:</label>
            <input type="text" id="searchBar" placeholder="Search for names..." />
        </div>
    </div>
        <!-- Empty Label filter -->
    <div>
        <label for="exactLabelFilter">Language Labels:</label>
        <select id="exactLabelFilter">
            <option value="any">Any Language</option>
            <option value="exactOne">Exactly One Language Per Project or Empty</option>
            <option value="en">English Only (en)</option>
            <option value="de">German Only (de)</option>
            <option value="en,de">English and German (en, de)</option>
        </select>
    </div>
    
    <div id="entityTable"></div>

    <script>
        document.addEventListener("DOMContentLoaded", () => {
            const loadingElement = document.getElementById("loading");
            const errorContainer = document.getElementById("errorContainer");
            const jsonContainer = document.getElementById("jsonContainer");
            const entityTableElement = document.getElementById("entityTable");
            const languageFilter = document.getElementById("languageFilter");
            const projectFilter = document.getElementById("projectFilter");
            const linkFilter = document.getElementById("linkFilter");
            const typeFilter = document.getElementById("typeFilter");
            const searchBar = document.getElementById("searchBar");

            function logError(message, error) {
                console.error(message, error);
                errorContainer.innerHTML = `
                    <h2>Error</h2>
                    <p>${message}</p>
                    <pre>${error ? error.toString() : 'Unknown error'}</pre>
                `;
                loadingElement.style.display = 'none';
            }
    
            async function fetchAndParseFile(url, type) {
                try {
                    const response = await fetch(url);
                    if (!response.ok) {
                        throw new Error(`Failed to fetch ${url}: HTTP ${response.status}`);
                    }
                    const text = await response.text();
                    const parser = new DOMParser();
                    const doc = parser.parseFromString(text, "application/xml");
                    if (doc.querySelector("parsererror")) {
                        throw new Error(`Invalid ${type} structure`);
                    }
                    return doc;
                } catch (error) {
                    logError(`Failed to load ${type} file`, error);
                    throw error;
                }
            }

            async function processXMLTransformation() {
                try {
                    console.log("Starting XML transformation process...");
                    //const url = 'http://localhost:8080/proxy?url=https://qhod.net/o:qhod.standOff/TEI_SOURCE';
                    const xml = await fetchAndParseFile("QhoDstandOff.xml", 'XML');

                    //const xml = await fetchAndParseFile('https://qhod.net/o:qhod.standOff/TEI_SOURCE', 'XML');
                    const xsl = await fetchAndParseFile('styles.xsl', 'XSL');
                    const personElements = xml.querySelectorAll("person");
                    const placeElements = xml.querySelectorAll("place");
                    console.log("Starting XSLT transformation...");
                    const xsltProcessor = new XSLTProcessor();
                    xsltProcessor.importStylesheet(xsl);

                    let resultFragment;
                    try {
                        resultFragment = xsltProcessor.transformToFragment(xml, document);
                        if (!resultFragment) {
                            throw new Error("XSLT transformation returned null or failed.");
                        }
                    } catch (transformError) {
                        console.error("XSLT Transformation Error:", transformError);
                        throw transformError;
                    }

                    const jsonText = resultFragment.textContent?.trim();
                    if (!jsonText) {
                        throw new Error("Transformation result is empty or invalid.");
                    }

                    const jsonData = JSON.parse(jsonText);
                    
                    // Debug: Log the first item's structure to see if authoritative_ids exists
                    if (jsonData && jsonData.length > 0) {
                        console.log("First entity structure:", JSON.stringify(jsonData[0], null, 2));
                    }
                    
                    loadingElement.style.display = 'none';
                    jsonContainer.style.display = 'block';
                    jsonContainer.innerHTML = JSON.stringify(jsonData, null, 2);

                    entityTableElement.style.display = 'block';
            
                    // Get unique languages, collections, and links from the data
                    const allLanguages = new Set();
                    const allCollections = new Set();
                    const allTypes = new Set(); // Collect unique types
                    const allLinks = new Set();

                    jsonData.forEach(entry => {
                        entry["additional names"]?.forEach(item => {
                            if (item.lang) {
                                allLanguages.add(item.lang);
                            }
                            if (item.collection) {
                                allCollections.add(item.collection);
                            }
                        });
                        entry["links"]?.forEach(linkObj => {
                            if (linkObj.link) {
                                allLinks.add(linkObj.link);
                            }
                        });
                        if (entry.type) {
                            allTypes.add(entry.type);  // Add type from the entry to the set
                        }
                    });

                    // Populate the language filter dropdown with unique languages
                    allLanguages.forEach(lang => {
                        const option = document.createElement("option");
                        option.value = lang;
                        option.textContent = lang;
                        languageFilter.appendChild(option);
                    });

                    // Populate the project filter dropdown with unique collections
                    allCollections.forEach(collection => {
                        const option = document.createElement("option");
                        option.value = collection;
                        option.textContent = collection;
                        projectFilter.appendChild(option);
                    });

                    // Populate the link filter dropdown with unique links
                    allLinks.forEach(link => {
                        const option = document.createElement("option");
                        option.value = link;
                        option.textContent = link;
                        linkFilter.appendChild(option);
                    });

                    // Populate the type filter dropdown with unique types from the data
                    allTypes.forEach(type => {
                        const option = document.createElement("option");
                        option.value = type;
                        option.textContent = type.charAt(0).toUpperCase() + type.slice(1);  // Capitalize the type name
                        typeFilter.appendChild(option);
                    });

                    // Filter function
                    function filterData(data) {
                        const selectedLanguage = languageFilter.value;
                        const selectedCollection = projectFilter.value;
                        const selectedLink = linkFilter.value;
                        const selectedType = typeFilter.value;
                        const searchQuery = searchBar.value.toLowerCase();
                        const exactLabelFilter = document.getElementById("exactLabelFilter").value;
                        
                        const searchWords = searchQuery.split(/\s+/).filter(Boolean);

                        return data.filter(entry => {
                            const additionalNames = entry["additional names"] || [];
                            const links = entry["links"] || [];

                            // More strict project match
                            const projectMatch = selectedCollection === "" || 
                                additionalNames.some(item => item.collection === selectedCollection);

                            // More strict label match
                            const labelMatch = (function () {
                                const additionalLangs = [
                                    ...new Set(
                                        additionalNames.map(item => item.lang).filter(Boolean)
                                    ),
                                ];
                                if (exactLabelFilter === "exactOne") {
                                    return additionalLangs.length === 1;
                                } else if (exactLabelFilter !== "any") {
                                    const filterLanguages = exactLabelFilter.split(",").map(lang => lang.trim());
                                    return additionalLangs.length === filterLanguages.length &&
                                        additionalLangs.every(lang => filterLanguages.includes(lang));
                                }
                                return true;
                            })();

                            // More strict link match
                            const linkMatch = selectedLink === "" || 
                                links.some(linkObj => linkObj.link === selectedLink);

                            // Type match
                            const typeMatch = !selectedType || entry.type === selectedType;

                            // More strict language match
                            const languageMatch = selectedLanguage === "" || 
                                additionalNames.some(item => item.lang === selectedLanguage);

                            // Search match
                            const searchMatch = searchWords.every(word =>
                                Object.values(entry).some(val => {
                                    if (typeof val === "string") return val.toLowerCase().includes(word);
                                    if (Array.isArray(val)) {
                                        return val.some(innerVal =>
                                            typeof innerVal === "string"
                                                ? innerVal.toLowerCase().includes(word)
                                                : Object.values(innerVal).some(nestedVal =>
                                                    typeof nestedVal === "string" && nestedVal.toLowerCase().includes(word)
                                                )
                                        );
                                    }
                                    return false;
                                })
                            );

                            return projectMatch && labelMatch && linkMatch && typeMatch && languageMatch && searchMatch;
                        });
                    }

                    function updateTable() {
                        const filteredData = filterData(jsonData);
                        table.setData(filteredData);
                    }

                    // Allowed values for project validation
                    const allowedProjects = ["QHOD_prefLabel", "QHOD_prefLabel-vipa", "QHOD_prefLabel-graviz"];

                    // Custom formatter for "Projects" column
                    function highlightInvalidProjects(cell) {
                        const namesArray = cell.getValue();
                        if (Array.isArray(namesArray)) {
                            // Check if at least one of the collections matches the allowed values
                            const hasValidProject = namesArray.some(item => allowedProjects.includes(item.collection));
                            if (!hasValidProject) {
                                // Highlight the cell if no valid project is found
                                cell.getElement().style.backgroundColor = "yellow";
                                cell.getElement().style.color = "black";
                            }
                            // Return a comma-separated list of collections for display
                            return namesArray.map(item => item.collection).join(", ");
                        }
                        return "No Projects"; // Default text if no array
                    }

                    // Initialize Tabulator
                    var table = new Tabulator("#entityTable", {
                        height: 400,
                        data: jsonData,
                        layout: "fitDataStretch",
                        rowHeader:{formatter:"rownum", headerSort:false, hozAlign:"center", resizable:false, frozen:true},
                        columns: [
                            { title: "Type", field: "type", width: 90 },
                            { 
                                title: "Name", 
                                field: "name", 
                                width: 150,
                                cellClick: function(e, cell) {
    // When the cell is clicked, show a popup with name and authority links
    var data = cell.getRow().getData();
    
    // Debug: Log the data to see what's available
    console.log("Clicked row data:", JSON.stringify(data, null, 2));
    
    // Create popup container with improved styling
    var popup = document.createElement("div");
    popup.className = "entity-popup";
    
    // Create popup header with icon and name
    var header = document.createElement("div");
    header.className = "entity-popup-header";
    
    // Add appropriate icon based on entity type
    var iconElement = document.createElement("div");
    iconElement.className = "entity-popup-icon";
    
    // Choose icon based on entity type
    if (data.type && data.type.toLowerCase() === "place") {
        // Place icon (location marker)
        iconElement.innerHTML = '<svg width="32" height="32" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M12 21C16 17 20 13.4183 20 9C20 4.58172 16.4183 1 12 1C7.58172 1 4 4.58172 4 9C4 13.4183 8 17 12 21Z" stroke="black" stroke-width="2"/><circle cx="12" cy="9" r="3" stroke="black" stroke-width="2"/></svg>';
    } else {
        // Default person icon
        iconElement.innerHTML = '<svg width="32" height="32" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><circle cx="12" cy="7" r="4" stroke="black" stroke-width="2"/><path d="M4 21V17C4 15.8954 4.89543 15 6 15H18C19.1046 15 20 15.8954 20 17V21" stroke="black" stroke-width="2"/></svg>';
    }
    
    // Add name
    var nameElement = document.createElement("h2");
    nameElement.className = "entity-popup-name";
    nameElement.textContent = data.name;
    
    // Add close button
    var closeButton = document.createElement("div");
    closeButton.className = "entity-popup-close";
    closeButton.innerHTML = '<svg width="16" height="16" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M18 6L6 18" stroke="#b35900" stroke-width="2" stroke-linecap="round"/><path d="M6 6L18 18" stroke="#b35900" stroke-width="2" stroke-linecap="round"/></svg>';
    closeButton.onclick = function() {
        popup.remove();
        document.removeEventListener("click", closePopupFunction);
    };
    
    // Add elements to header
    header.appendChild(iconElement);
    header.appendChild(nameElement);
    header.appendChild(closeButton);
    
    // Create content section
    var content = document.createElement("div");
    content.className = "entity-popup-content";
    
    // Add birth-death years if available (for persons)
    if (data.type && data.type.toLowerCase() === "person") {
        var yearsText = "";
        if (data.birth && data.birth.when) {
            yearsText += data.birth.when.substring(0, 4);
        }
        yearsText += "–";
        if (data.death && data.death.when) {
            yearsText += data.death.when.substring(0, 4);
        }
        
        if (yearsText !== "–") {
            var yearsElement = document.createElement("p");
            yearsElement.className = "entity-popup-years";
            yearsElement.textContent = yearsText;
            content.appendChild(yearsElement);
        }
    }
    
    // Add occupation (for persons) or description (for places) if available
    if (data.occupation) {
        var occupationElement = document.createElement("p");
        occupationElement.className = "entity-popup-occupation";
        occupationElement.textContent = data.occupation;
        content.appendChild(occupationElement);
    }
    
    // Add alternative names with project information if available
    if (Array.isArray(data['additional names']) && data['additional names'].length > 0) {
        var altNamesDiv = document.createElement("div");
        altNamesDiv.className = "entity-popup-section";
        
        var altNameTitle = document.createElement("p");
        altNameTitle.className = "entity-popup-section-title";
        altNameTitle.textContent = "Alternative Names:";
        altNamesDiv.appendChild(altNameTitle);
        
        var namesList = document.createElement("ul");
        namesList.className = "entity-popup-list";
        
        data['additional names'].forEach(function(item) {
            var listItem = document.createElement("li");
            
            // Add name
            var nameSpan = document.createElement("span");
            nameSpan.textContent = item.name;
            listItem.appendChild(nameSpan);
            
            // Add language if available
            if (item.lang) {
                var langSpan = document.createElement("span");
                langSpan.className = "entity-popup-lang";
                langSpan.textContent = " (" + item.lang + ")";
                listItem.appendChild(langSpan);
            }
            
            // Add project/collection if available
            if (item.collection) {
                var projectSpan = document.createElement("span");
                projectSpan.className = "entity-popup-project";
                projectSpan.textContent = " [" + item.collection + "]";
                listItem.appendChild(projectSpan);
            }
            
            namesList.appendChild(listItem);
        });
        
        altNamesDiv.appendChild(namesList);
        content.appendChild(altNamesDiv);
    }
    
    // Find GND links
    var gndLinks = [];
    
    // Check in authoritative_ids - handling both possible structures
    if (Array.isArray(data['authoritative_ids'])) {
        // First structure: array of objects with type/url properties
        const gndByType = data['authoritative_ids'].filter(id => id.type === 'GND');
        if (gndByType.length > 0) {
            gndLinks = gndLinks.concat(gndByType);
        }
        
        // Second structure: array of objects with direct GND property
        const gndByProperty = data['authoritative_ids'].filter(id => id.GND);
        if (gndByProperty.length > 0) {
            gndByProperty.forEach(item => {
                gndLinks.push({
                    type: 'GND',
                    url: item.GND
                });
            });
        }
    }
    
    // Add GND link if available
    if (gndLinks.length > 0) {
        var gndContainer = document.createElement("div");
        gndContainer.className = "entity-popup-gnd";
        
        var gndLabel = document.createElement("strong");
        gndLabel.textContent = "GND: ";
        gndContainer.appendChild(gndLabel);
        
        var gndLink = document.createElement("a");
        gndLink.href = gndLinks[0].url;
        gndLink.target = "_blank";
        gndLink.className = "entity-popup-link";
        gndLink.textContent = gndLinks[0].url;
        gndContainer.appendChild(gndLink);
        
        content.appendChild(gndContainer);
    }
    
    // Add elements to popup
    popup.appendChild(header);
    popup.appendChild(content);
    
    // Position the popup relative to the clicked cell
    var cellRect = cell.getElement().getBoundingClientRect();
    popup.style.top = cellRect.top + window.scrollY + cellRect.height + 10 + "px";
    popup.style.left = cellRect.left + window.scrollX + "px";
    
    // Append popup to body
    document.body.appendChild(popup);
    
    // Define the close popup function
    function closePopupFunction(e) {
        if (!popup.contains(e.target) && e.target !== cell.getElement()) {
            popup.remove();
            document.removeEventListener("click", closePopupFunction);
        }
    }
    
    // Close the popup when clicking anywhere outside of it
    document.addEventListener("click", closePopupFunction);
} 
                            },
                            { 
                                title: "Id", 
                                field: "id", 
                                width: 180, 
                                formatter: "link",
                                formatterParams: {
                                    label: "Click here for MPR Data", 
                                    labelField: "id", 
                                    url: function (cell){
                                        const idsArray = cell.getValue();
                                        if (Array.isArray(idsArray)) {
                                            return (idsArray.map(item => item.id).join(", "));
                                        }
                                    }
                                },
                            }, 
                            {
                                title: "Additional names",  // Column title
                                field: "additional names",  // Field name
                                width: 100,  // Column width
                                formatter: function(cell) {
                                    const namesArray = cell.getValue();
                                    if (Array.isArray(namesArray)) {
                                        return namesArray.map(item => item.name).join(", ");
                                    }
                                    return "No Additional names";
                                },
                                cellClick: function(e, cell) {
                                    // When the cell is clicked, show a popup specific to this cell
                                    var data = cell.getRow().getData();  // Get the row data
                                    var container = document.createElement("div");
                                    var contents = "<strong style='font-size:1.2em;'>Additional Names</strong><br/><ul style='padding:0; margin-top:10px; margin-bottom:0;'>";

                                    // Check if additional names exist and are an array
                                    if (Array.isArray(data['additional names']) && data['additional names'].length > 0) {
                                        // Loop through the array of additional names and display each name
                                        data['additional names'].forEach(function(item) {
                                            contents += "<li><strong>Name:</strong> " + item.name + "</li>";
                                        });
                                    } else {
                                        // If no additional names are found, show a message
                                        contents += "<li>No additional names available</li>";
                                    }

                                    contents += "</ul>";
                                    
                                
                                    // Add the content to the container
                                    container.innerHTML = contents;

                                    // Create the popup and append it to the body or the cell's parent
                                    var popup = document.createElement("div");
                                    popup.style.position = "absolute";
                                    popup.style.zIndex = 1000;
                                    popup.style.backgroundColor = "#fff";
                                    popup.style.border = "1px solid #ddd";
                                    popup.style.padding = "10px";
                                    popup.style.maxWidth = "300px";
                                    popup.style.boxShadow = "0px 0px 10px rgba(0,0,0,0.2)";
                                    popup.innerHTML = container.innerHTML;

                                    // Position the popup relative to the clicked cell
                                    var cellRect = cell.getElement().getBoundingClientRect();
                                    popup.style.top = cellRect.top + window.scrollY + cellRect.height + 10 + "px"; // Position below the cell
                                    popup.style.left = cellRect.left + window.scrollX + "px"; // Position next to the cell

                                    document.body.appendChild(popup);

                                    // Optional: Close the popup when clicking anywhere outside of it
                                    function closePopup(e) {
                                        if (!popup.contains(e.target) && e.target !== cell.getElement()) {
                                            popup.remove();
                                            document.removeEventListener("click", closePopup);
                                        }
                                    }
                                    document.addEventListener("click", closePopup);
                                }
                            },
                            {
                                title: "Languages",
                                field: "additional names", 
                                width: 50, 
                                formatter: function (cell) {
                                    const namesArray = cell.getValue();
                                    if (Array.isArray(namesArray)) {
                                        return namesArray.map(item => item.lang).join(", ");
                                    }
                                    return "No Languages";
                                }
                            },
                            {
                                title: "Projects",
                                field: "additional names", 
                                width: 180,
                                formatter: highlightInvalidProjects, // Apply the custom formatter
                                cellClick: function(e, cell) {
                                    // When the cell is clicked, show a popup specific to this cell
                                    var data = cell.getRow().getData();  // Get the row data
                                    var container = document.createElement("div");
                                    var contents = "<strong style='font-size:1.2em;'>Related projects</strong><br/><ul style='padding:0; margin-top:10px; margin-bottom:0;'>";

                                    // Check if additional names exist and are an array
                                    if (Array.isArray(data['additional names']) && data['additional names'].length > 0) {
                                        // Loop through the array of additional names and display each name
                                        data['additional names'].forEach(function(item) {
                                            contents += "<li><strong>Project labels:</strong> " + item.collection + "</li>";
                                        });
                                    } else {
                                        // If no additional names are found, show a message
                                        contents += "<li>No project labels available</li>";
                                    }
                                    contents += "</ul>";
                                    
                                    

                                    // Add the content to the container
                                    container.innerHTML = contents;

                                    // Create the popup and append it to the body or the cell's parent
                                    var popup = document.createElement("div");
                                    popup.style.position = "absolute";
                                    popup.style.zIndex = 1000;
                                    popup.style.backgroundColor = "#fff";
                                    popup.style.border = "1px solid #ddd";
                                    popup.style.padding = "10px";
                                    popup.style.maxWidth = "300px";
                                    popup.style.boxShadow = "0px 0px 10px rgba(0,0,0,0.2)";
                                    popup.innerHTML = container.innerHTML;

                                    // Position the popup relative to the clicked cell
                                    var cellRect = cell.getElement().getBoundingClientRect();
                                    popup.style.top = cellRect.top + window.scrollY + cellRect.height + 10 + "px"; // Position below the cell
                                    popup.style.left = cellRect.left + window.scrollX + "px"; // Position next to the cell

                                    document.body.appendChild(popup);

                                    // Optional: Close the popup when clicking anywhere outside of it
                                    function closePopup(e) {
                                        if (!popup.contains(e.target) && e.target !== cell.getElement()) {
                                            popup.remove();
                                            document.removeEventListener("click", closePopup);
                                        }
                                    }
                                    document.addEventListener("click", closePopup);
                                }
                            },
                            {
                                title: "Links",
                                field: "links", 
                                width: 100, 
                                resizable:false,
                                formatter: function (cell) {
                                    const linksArray = cell.getValue();
                                    if (Array.isArray(linksArray)) {
                                        return linksArray.map(linkObj => linkObj.link).join(", ");
                                    }
                                    return "No Links";
                                }
                            },
                            {
                                title: "When and Who", // New column
                                field: "when", // Field where the 'when' and 'who' data is stored
                                width: 200,
                                formatter: function(cell) {
                                    const whenData = cell.getValue(); // Access the 'when' field from JSON data
                                    if (Array.isArray(whenData) && whenData.length > 0) {
                                        // Extract "when" and "who" values safely
                                        return whenData.map(item => {
                                            if (item.when) {
                                                const [timestamp, user] = item.when.split(": ");
                                                if (timestamp && user) {
                                                    return `<div><strong>When:</strong> ${timestamp}</div>
                                                            <div><strong>Who:</strong> ${user}</div>`;}
                                                return `<div>Invalid Data</div>`; // Handle malformed 'when' entries
                                            }
                                            return `<div>No Data</div>`; // When 'when' field is empty or invalid
                                        }).join("<br>");
                                    }
                                    return `<div>No Data</div>`; // When 'when' field is empty or invalid
                                }
                            },
                        ],
                    });

                    // Attach event listeners to filters
                    languageFilter.addEventListener("change", updateTable);
                    projectFilter.addEventListener("change", updateTable);
                    linkFilter.addEventListener("change", updateTable);
                    typeFilter.addEventListener("change", updateTable);
                    searchBar.addEventListener("input", updateTable);
                    exactLabelFilter.addEventListener("change", updateTable);

                    updateTable(); // Initial table update
                } catch (error) {
                    console.error("Error:", error);
                }
            }

            processXMLTransformation();
        });
    </script>
</body>
</html>
